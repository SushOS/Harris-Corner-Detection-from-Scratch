# -*- coding: utf-8 -*-
"""B21CS084_qu1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XOi0owMgHTUTApyxLiaa8S2xD0w2ftKR

# Uploading the Images (Will work only on Google Colab)
"""

from google.colab import files
uploaded = files.upload()

"""# Necessary Imports"""

import numpy as np
import cv2
from google.colab.patches import cv2_imshow
import imageio
import matplotlib.pyplot as plt
from tqdm import tqdm

"""# Function for Convolution"""

def convolve(image, kernel):
    height, width = image.shape
    k_size = kernel.shape[0]
    pad = k_size // 2
    padded_image = np.pad(image, pad, mode='constant')

    convolved_image = np.zeros_like(image, np.float32)
    for i in tqdm(range(height)):
        for j in range(width):
            convolved_image[i, j] = np.sum(padded_image[i:i+k_size, j:j+k_size] * kernel)

    return convolved_image

"""# Compute Gradients of Image"""

def compute_gradients(image):
    # Compute gradients in x and y directions using Sobel operators
    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    sobel_y = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]])
    gradient_x = convolve(image, sobel_x)
    gradient_y = convolve(image, sobel_y)
    return gradient_x, gradient_y

"""# Gaussian Kernel"""

def gaussian_kernel(size, sigma):
    kernel = np.fromfunction(lambda x, y: (1 / (2 * np.pi * sigma**2)) * np.exp(-((x - size//2)**2 + (y - size//2)**2) / (2 * sigma**2)), (size, size))
    kernel /= np.sum(kernel)  # Normalize the kernel
    return kernel

"""# Gaussian Blur"""

def gaussian_blur(image, size, sigma):
    # Generate Gaussian kernel
    kernel = gaussian_kernel(size, sigma)
    # Perform convolution
    blurred_image = convolve(image, kernel)
    return blurred_image

"""# Magnitude of Gradients"""

# Compute the magnitude of gradients
def mag_grads(image):
    ht, wid = image.shape
    for i in range(ht):
        for j in range(wid):
            if image[i][j] < 0:
                image[i][j] *= -1
    return image

"""# Constructing Matrix M"""

# Computing the matrix M parameters
def mat_params(ix, iy):
    ix_2 = np.square(ix)
    iy_2 = np.square(iy)
    ixy = np.multiply(ix, iy)
    iyx = np.multiply(iy, ix)
    return ix_2, iy_2, ixy, iyx

"""# Harris corner strength (R)"""

def HCD_R(ix_2, iy_2, ixy, iyx, sigma, alpha, kernel_size):
    # Compute corner strength (R) using Harris corner detection algorithm
    Ixx = gaussian_blur(ix_2, kernel_size, sigma)
    Iyy = gaussian_blur(iy_2, kernel_size, sigma)
    Ixy = gaussian_blur(ixy, kernel_size, sigma)
    Iyx = gaussian_blur(iyx, kernel_size, sigma)

    R = np.zeros_like(ix_2, np.float32)
    ht, wid = ix_2.shape
    for y in tqdm(range(ht)):
        for x in range(wid):
            M = np.array([[Ixx[y, x], Iyy[y, x]], [Ixy[y, x], Iyx[y, x]]])
            R[y, x] = np.linalg.det(M) - alpha * (np.trace(M) ** 2)
    return R

"""# Detecting Corners"""

def detect_corners(R, threshold):
    # Detect corners based on the corner strength and a threshold
    # Non-maximum suppression is also applied to find local maxima in 4*4 window
    # R is the corner strength matrix
    # threshold is the minimum value of R to consider a corner
    corners = []
    height, width = R.shape
    for y in tqdm(range(height)):
        for x in range(width):
            if R[y, x] > threshold:
                is_local_maxima = True
                for dy in range(-2, 2): # 4*4 window size is used
                    for dx in range(-2, 2):
                        ny, nx = y + dy, x + dx
                        if 0 <= ny < height and 0 <= nx < width and R[ny, nx] > R[y, x]:
                            is_local_maxima = False
                            break
                    if not is_local_maxima:
                        break
                if is_local_maxima:
                    corners.append((x, y))
    return corners # return the list of corner coordinates

"""# Image Paths"""

image_paths = [
    "/content/1.gif",
    "/content/2.jpeg",
    "/content/3.png",
    "/content/5.jpg",
    "/content/6.jpg",
    "/content/7.jpg",
    "/content/8.jpg",
    "/content/9.jpeg",
    "/content/10.jpg",
    "/content/11.jpg"
]

"""# Corner Detection from Scratch"""

cnt = 1
corners_scratch = []
for image_path in image_paths:
    print(f"Detecting Corners of Image {cnt}")
    if image_path.endswith('.gif'):
        gif = imageio.mimread(image_path)
        image = gif[0]
        colored_image = image
    else:
        image = cv2.imread(image_path)
        colored_image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    ix, iy = compute_gradients(gray_image)
    ix = mag_grads(ix)
    iy = mag_grads(iy)
    ix_2, iy_2, ixy, iyx = mat_params(ix, iy)

    kernel_size = 3
    sigma = 0.8
    alpha = 0.04
    R = HCD_R(ix_2, iy_2, ixy, iyx, sigma, alpha, kernel_size)

    # Detect corners
    threshold = 0.01*np.max(R)
    corners = detect_corners(R, threshold)
    cnt = cnt+1
    # Draw detected corners on the colored image
    for corner in corners:
        cv2.circle(colored_image, tuple(corner), 3, (0, 0, 255), -1)  # Blue color for corners

    # Display the result
    corners_scratch.append(colored_image)
    cv2_imshow(colored_image)
    cv2.waitKey(0)
cv2.destroyAllWindows()

"""# Corner Detection Using OpenCV"""

cnt = 1
corners_library = []
for image_path in image_paths:
    print(f"Detecting Corners of Image {cnt}")

    # Load Image
    if image_path.endswith('.gif'):
        gif = imageio.mimread(image_path)
        input_image = gif[0]

    else:
        input_image = cv2.imread(image_path)

    # Convert to grayscale
    gray_image = cv2.cvtColor(input_image, cv2.COLOR_BGR2GRAY)

    # Apply Gaussian blur to the grayscale image
    blurred_image = cv2.GaussianBlur(gray_image, (3, 3), 0)

    # Apply cv2.cornerHarris() function
    harris_corners = cv2.cornerHarris(blurred_image, 2, 3, 0.04)

    # Dilate corners for better marking
    harris_corners = cv2.dilate(harris_corners, None)

    # Define a threshold for extracting large corners
    threshold = 0.01 * harris_corners.max()
    cnt = cnt+1
    # Iterate through all the corners and draw them
    for i in range(harris_corners.shape[0]):
        for j in range(harris_corners.shape[1]):
            if harris_corners[i, j] > threshold:
                # Draw a red circle at each corner
                cv2.circle(input_image, (j, i), 1, (0, 0, 255), -1)

    # Display the image with corners
    corners_library.append(input_image)
    cv2_imshow(input_image)
    cv2.waitKey(0)

cv2.destroyAllWindows()

"""# Side by Side Comaparision of corner Detection"""

num_images = len(corners_scratch)

# Create a new figure with specified size
plt.figure(figsize=(20, 60))

for i in range(num_images):
    plt.subplot(num_images, 2, 2*i + 1)
    plt.imshow(cv2.cvtColor(corners_scratch[i], cv2.COLOR_BGR2RGB))
    plt.title('Scratch Image {}'.format(i + 1))
    plt.axis('off')

    plt.subplot(num_images, 2, 2*i + 2)
    plt.imshow(cv2.cvtColor(corners_library[i], cv2.COLOR_BGR2RGB))
    plt.title('OpenCV Image {}'.format(i + 1))
    plt.axis('off')

plt.tight_layout()
plt.show()
